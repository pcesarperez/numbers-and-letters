/*
 * build.gradle
 *
 * Building script for 'numbers-and-letter` library.
 */

defaultTasks 'createAssemblies'


apply plugin: 'java'
apply plugin: 'antlr'
apply plugin: 'maven-publish'
apply plugin: 'idea'


/**
 * Sourcesets used both for debug and release building.
 */
sourceSets {
    debug {
        java {
            srcDirs = ["src/main/java", new File (buildDir, 'generated-src/antlr/main')]
            outputDir = new File (buildDir, "debug/classes/java/main")
        }

        resources {
            srcDirs = ["src/main/resources"]
        }
    }

    release {
        java {
            srcDirs = ["src/main/java", new File (buildDir, 'generated-src/antlr/main')]
            outputDir = new File (buildDir, "release/classes/java/main")
        }

        resources {
            srcDirs = ["src/main/resources"]
        }
    }

    test.java.outputDir = new File (buildDir, "classes/java/test")
}


/**
 * IntelliJ Idea specific properties.
 *
 * IntelliJ Idea needs the generated sources folder explicitly declared.
 * https://discuss.gradle.org/t/how-do-i-get-intellij-to-recognize-gradle-generated-sources-dir/16847/4
 */
idea {
    module {
        generatedSourceDirs += file ('build/generated-src')
    }
}


/**
 * External properties.
 */
Properties properties = new Properties ( )
properties.load (new FileInputStream ('build.properties'))


/**
 * Assembly coordinates.
 */
group = properties.assemblyGroup
version = properties.assemblyVersion


/**
 * Manifest file.
 */
ext.sharedManifest = manifest {
    attributes (
        'Specification-Title': properties.specificationTitle,
        'Specification-Version': properties.specificationVersion,
        'Specification-Vendor': properties.specificationVendor,
        'Implementation-Title': properties.implementationTitle,
        'Implementation-Version': properties.implementationVersion,
        'Implementation-Vendor': properties.implementationVendor,
        'Class-Path': properties.classPath
    )
}


/**
 * Repositories.
 */
repositories {
    mavenCentral ( )
    mavenLocal ( )
}

/**
 * Wrapper creation.
 */
wrapper {
    gradleVersion = "4.10.2"
}


/**
 * Publishing to local Maven repo.
 *
 * Use `gradle publishToMavenLocal` to upload the assembly to the local Maven repository.
 */
publishing {
    publications {
        mavenJava (MavenPublication) {
            from components.java
        }
    }
}


/**
 * Compiler settings.
 */
sourceCompatibility = properties.sourceCompatibility
targetCompatibility = properties.targetCompatibility


/**
 * ANTLR code generation from grammars.
 */
generateGrammarSource {
    doFirst ( ) {
        println "Generating source code from grammar files..."
    }

    arguments += ['-package', 'com.adastrafork.numbersandletters.generated.antlr4']
    arguments += ['-visitor', '-no-listener']
    outputDirectory = new File (buildDir, properties.generatedSourcesDir.toString ( ))
}


/**
 * Cleaning process.
 */
clean {
    delete "generated-src"
}


/**
 * Dependencies.
 */
dependencies {
    antlr "org.antlr:antlr4:4.5.3"
    runtime "org.antlr:antlr4-runtime:4.5.3"
    testImplementation ('org.junit.jupiter:junit-jupiter-api:5.1.0')
    testRuntimeOnly ('org.junit.jupiter:junit-jupiter-engine:5.1.0')
}


/**
 * Testing properties.
 */
test {
    useJUnitPlatform ( )
}


/**
 * Task to show information about the assembly.
 */
task info {
    info.description = 'Shows assembly information.'

    doFirst ( ) {
        println ''
        println '\t|Assembly info:'
        println '\t|'
        println '\t|\tgroupId: ' + properties.assemblyGroup
        println '\t|\tartifactId: ' + properties.assemblyName
        println '\t|\tversion: ' + properties.assemblyVersion
    }
}


/**
 * Task to compile the source code in debug mode.
 */
task compileDebug (type: JavaCompile, dependsOn: ['clean', 'generateGrammarSource']) {
    doFirst ( ) {
        println "Compiling debug code..."
    }

    source = sourceSets.debug.java.srcDirs
    destinationDir = sourceSets.debug.java.outputDir
    classpath = project.sourceSets.main.compileClasspath

    options.fork = properties.compilerFork.toBoolean ( )
    options.incremental = properties.incrementalBuild.toBoolean ( )
    options.encoding = properties.sourceEncoding
    options.verbose = properties.verboseBuild.toBoolean ( )
    options.debug = true
    options.debugOptions.debugLevel = 'source,lines,vars'
}


/**
 * Task to compile the source code in release mode.
 */
task compileRelease (type: JavaCompile, dependsOn: ['clean', 'generateGrammarSource']) {
    doFirst ( ) {
        println "Compiling release code..."
    }

    source = sourceSets.release.java.srcDirs
    destinationDir = sourceSets.release.java.outputDir
    classpath = project.sourceSets.main.compileClasspath

    options.fork = properties.compilerFork.toBoolean ( )
    options.incremental = properties.incrementalBuild.toBoolean ( )
    options.encoding = properties.sourceEncoding
    options.verbose = properties.verboseBuild.toBoolean ( )
    options.debug = false
}


/**
 * Main task to create the assemblies, one per compilation mode.
 */
task createAssemblies (dependsOn: ['createAssemblyDebug', 'createAssemblyRelease'])


/**
 * Task to create the assembly using code compiled in debug mode.
 */
task createAssemblyDebug (type: Jar, dependsOn: 'compileDebug') {
    doFirst ( ) {
        println 'Creating assembly for development/acceptance environments...'
    }

    from sourceSets.debug.java.outputDir
    destinationDir = file (properties.jarDebugDir)
    baseName = properties.assemblyName
    version = properties.assemblyVersion

    manifest = project.manifest {
        from sharedManifest
    }
}


/**
 * Task to create the assembly using code compiled in release mode.
 */
task createAssemblyRelease (type: Jar, dependsOn: 'compileRelease') {
    doFirst ( ) {
        println 'Creting assembly for production environments...'
    }

    from sourceSets.release.java.outputDir
    destinationDir = file (properties.jarReleaseDir)
    baseName = properties.assemblyName
    version = properties.assemblyVersion

    manifest = project.manifest {
        from sharedManifest
    }
}